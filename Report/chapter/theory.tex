\chapter{Theory}

This chapter will give an introduction to the FFT algorithm and a brief introduction of the Graphics Processing Unit (GPU).

\section{Graphics Processing Unit}

A GPU is traditionally specialized hardware for efficient manipulation of computer graphics and image processing. The inherent parallel structure of images and graphics makes them very efficient at some more general problems where parallelism can be exploited. The concept of General-purpose computing on graphics processing units (GPGPU) is applying a problem to the GPU platform instead of the CPU or multi-core system.

\subsection{Graphics hardware pipeline}

The traditional GPU can be described as a pipeline of a few linked steps. Every step receives input from the previous, processes the input and send it to the next. 

\subsection{GPGPU}

In the early days of GPGPU one had to rely on knowing a lot of graphics abstractions since the then available APIs was created with graphic processing in mind. The dominant APIs was OpenGL and DirectX (Direct3D).

\subsection{GPU vs CPU}

The GPU is build on a principle of more execution units instead of higher clock-frequency to improve performance. Comparing the two and the GPU performs a much higher floating point operations per second (FLOP) if running at optimal conditions. What the GPU sacrifice is the ability to run one task in sequential. The GPU relies much on using high memory bandwidth and fast context switching (run the next warp of threads) to compensate for lower frequency. The CPU is excellent at sequential tasks and uses branch prediction and ... among other finesses that is not used on the GPU.

\section{Fast Fourier Transform}

The Fast Fourier Transform is by far mostly associated with the Cooley-Tukey algorithm.

\subsection{FFT Cooley-Tukey}

The Cooley-Tukey algorithm is a devide and conquer algorithm that recursively breaks down a DFT of any composite size of $N = N_1{\cdot}N_2$.  

"
This is a divide and conquer algorithm that recursively breaks down a DFT of any composite size N = N1N2 into many smaller DFTs of sizes N1 and N2, along with O(N) multiplications by complex roots of unity traditionally called twiddle factors (after Gentleman and Sande, 1966[11]).
"

\subsubsection{FFT Constant Geometry}

Essentially the same algorithm but with some clever indexing the structure of the FFT do not changes through the stages and the indexing stays the same.

\subsection{FFT parallelism}

By looking at the FFT algorithm illustrated, it is easy to see how one can split operations over parallel tasks. Naturally one can start by selecting one thread per data input, however that would lead to unbalanced load as the second input is multiplied by the twiddle factor. By selecting one thread per butterfly operation each thread will share the same arithmetic workload.

\subsubsection{Problems parallelizing}

Memory latencies can be hidden by caches and fast context switching, however the distance in memory will matter. Large distances between data in the butterfly operations will make the memory the bottleneck. Coalesced memory read goes well with good context switching since the fewer memory request will be performed.

\subsection{FFT on GPU}

The complete FFT algorithm was implemented in two kernels, one kernel running a single stage and one kernel running the last stages that could fit within one block. The single-stage kernel, called \textit{global kernel}, would execute in sequential order each stage of the algorithm. Each execution would require in total as many threads as there are butterfly-operations. The host would supply the kernel with a \textit{bitmask} created a bitwise left shift operation.

\begin{algorithm}
	\centering
	\begin{algorithmic}[1]
		\Procedure{GlobalKernel}{$data, bitmask, angle, stage, dist$}
            \State $tid \gets \Call{GlobalThreadId}{}$ 
            \State $low \gets tid + (tid \And bitmask)$
            \State $high \gets low + dist$
            \newline
            %\State // Calculate twiddle-factor
            \State $twMask \gets \Call{ShiftLeft}{dist - 1, stage}$
            \State $twStage \gets \Call{PowerOfTwo}{stage} \cdot tid$
            \State $a \gets angle \cdot (twStage \And twMask)$
            \State $\Call{Imag}{twiddleFactor} \gets \Call{Sin}{a}$
            \State $\Call{Real}{twiddleFactor} \gets \Call{Cos}{a}$
            \newline
            %\State // Calculate butterfly-operations
            \State $temp \gets \Call{ComplexSub}{data_{low}, data_{high}}$
            \State $data_{low} \gets \Call{ComplexAdd}{data_{low}, data_{high}}$
            \State $data_{high} \gets \Call{ComplexMul}{temp, twiddleFactor}$
        \EndProcedure
	\end{algorithmic}
	\caption{Pseudo-code for the global kernel with input from the host.}
	\label{alg:device:global-kernel}
\end{algorithm}

\begin{algorithm}
	\centering
	\begin{algorithmic}[1]
		\Procedure{LocalKernel}{$in$, $out$, $angle$, $stages$, $leadingBits$, $c$, $range$}
            \State let $shared$ be a shared/local memory buffer     
            \State $low  \gets \Call{ThreadId}{}$
            \State $high \gets low + range$   
            \State $offset \gets blockId \cdot blockDim \cdot 2$
            \State $shared_{low}  \gets in_{low + offset}$
            \State $shared_{high} \gets in_{high + offset}$
            \State $\Call{ConstantGeometry}{shared, low, high, angle, stages}$
            \State $revLow  \gets \Call{BitReverse}{low + offset, leadingBits}$
            \State $revHigh \gets \Call{BitReverse}{high + offset, leadingBits}$
            \State $out_{revLow}  \gets \Call{ComplexMul}{c, shared_{low}}$
            \State $out_{revHigh} \gets \Call{ComplexMul}{c, shared_{high}}$
        \EndProcedure
        \Statex
        \Procedure{ConstantGeometry}{$shared$, $low$, $high$, $angle$, $stages$}
            \State $outI \gets low \cdot 2$
            \State $outII \gets outI + 1$
            \For {$stage \gets 0, stages - 1$}
            	\State $bitmask \gets \Call{ShiftLeft}{0xFFFFFFFF, stage}$
            	\State $a \gets angle \cdot (low \And bitmask)$
            	\State $\Call{Imag}{twiddleFactor} \gets \Call{Sin}{a}$
            	\State $\Call{Real}{twiddleFactor} \gets \Call{Cos}{a}$
				\State $temp \gets \Call{ComplexSub}{shared_{low}, shared_{high}}$
				\State $shared_{outI} \gets \Call{ComplexAdd}{shared_{low}, shared_{high}}$
				\State $shared_{outII} \gets \Call{ComplexMul}{twiddleFactor, temp}$
			\EndFor
        \EndProcedure
	\end{algorithmic}
	\caption{Pseudo-code for the local kernel with input from the host.}
	\label{alg:device:local-kernel}
\end{algorithm}