// CUDA
__device__ __inline void cu_global(cpx *in, float angle, int steps, int dist)
{
    cpx w;
	int tid = blockIdx.x * blockDim.x + threadIdx.x;
    in += tid + (tid & lmask);
    __sincosf(angle * ((tid << steps) & ((dist - 1) << steps)), &w.y, &w.x);    
    cpx *h = in + dist;
    float x = in->x - h->x;
    float y = in->y - h->y;
    *in = { in->x + h->x, in->y + h->y };
    *h = { (w.x * x) - (w.y * y), (w.y * x) + (w.x * y) };
}

// OCL
__kernel void ocl_global(__global cpx *in, float angle, unsigned int lmask, int steps, int dist)
{
    cpx w;
    int tid = get_global_id(0);
    in += tid + (tid & lmask);
    w.y = sincos(angle * ((tid << steps) & ((dist - 1) << steps)), &w.x);    	
	cpx *high = in + dist;
	float x = in->x - high->x;
    float y = in->y - high->y;
    in->x = in->x + high->x;
    in->y = in->y + high->y;
    high->x = (w.x * x) - (w.y * y);
    high->y = (w.y * x) + (w.x * y);
}

// GL
void main()
{
    cpx w;
	uint tid = gl_GlobalInvocationID.x;
    uint in_low = tid + (tid & lmask);
    uint in_high = in_low + dist;    
	float a = global_angle * ((tid << steps) & ((dist - 1U) << steps));    
    w.x = cos(a);
    w.y = sin(a);
    cpx low = data[in_low];
    cpx high = data[in_high];
    float x = low.x - high.x;
    float y = low.y - high.y;
    data[in_low] = cpx(low.x + high.x, low.y + high.y);
    data[in_high] = cpx((w.x * x) - (w.y * y), (w.y * x) + (w.x * y));
}

// DX
[numthreads(GROUP_SIZE_X, 1, 1)]
void dx_global(uint3 threadIDInGroup : SV_GroupThreadID,
    uint3 groupID : SV_GroupID,
    uint groupIndex : SV_GroupIndex,
    uint3 dispatchThreadID : SV_DispatchThreadID)
{
    cpx w;
	int tid = groupID.x * GROUP_SIZE_X + threadIDInGroup.x;
    int in_low = tid + (tid & lmask);
    int in_high = in_low + dist;    
    sincos(global_angle * ((tid << steps) & ((dist - 1) << steps)), w.y, w.x);	
	float x = input[in_low].x - input[in_high].x;
    float y = input[in_low].y - input[in_high].y;
    rw_buf[in_low].x  = input[in_low].x + input[in_high].x;
    rw_buf[in_low].y  = input[in_low].y + input[in_high].y;
    rw_buf[in_high].x = (w.x * x) - (w.y * y);
    rw_buf[in_high].y = (w.y * x) + (w.x * y);
}